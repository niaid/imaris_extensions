<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Colocalization Analysis</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="midnight-green.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Colocalization Analysis</h1>
</header>
<p><a href="https://github.com/niaid/imaris_extensions">View on
GitHub</a></p>
<p>This program computes colocalization characteristics of two channels,
optionally using a third channel to define a sub-region of interest. The
binary image defining the colocalized image region is added to the input
image. If the binary sub-region of interest isn't the whole image, it is
added to the input image too. The channels are named "colocalization of
channels A and B" and "ROI used with colocalization of channels A and
B", where A and B are the original channel names. The specific SimpleITK
expressions used to create these channels appear in the channel
description. The output includes a single or multiple
comma-separated-value file(s) with the values for each of the
characteristics. Optionally, corresponding graphs are saved using output
format(s) selected by the user.</p>
<p>Usage of channel names to identify the channels allows batch
processing of images where corresponding channels do not have the same
index. For example CD3 may be in channel 0 in one image and in channel 3
in another.</p>
<p><strong>Note</strong>: Repeated channel names in a file are
considered invalid and the file will not be analyzed (e.g. Nuclei is the
name of channels 0 and 2).</p>
<p>For an overview of colocalization analysis in the context of
fluorescence microscopy see:</p>
<ul>
<li><ol start="10" type="A">
<li><ol start="19" type="A">
<li>Aaron, A. B. Taylor, T.-L. Chew, "Image co-localization â€“
co-occurrence versus correlation", J Cell Sci, <a
href="https://doi.org/10.1242/jcs.211847">doi:10.1242/jcs.211847</a>,
2018.</li>
</ol></li>
</ol></li>
<li><ol start="11" type="A">
<li><ol start="23" type="A">
<li>Dunn, M. M. Kamocka, J. H. McDonald, "A practical guide to
evaluating colocalization in biological microscopy", Am J Physiol Cell
Physiol., <a href="https://doi.org/10.1152/ajpcell.00462.2010">doi:
10.1152/ajpcell.00462.2010</a>, 2011.</li>
</ol></li>
</ol></li>
</ul>
<p>The characteristics include (open the settings dialog to select which
characteristics to compute, default is all):</p>
<ol>
<li>Percentage image colocalized, <span
class="math inline">$\frac{N_{Colocalized}}{N_{Image}}$</span>.</li>
<li>Percentage of channel colocalized, <span
class="math inline">$\frac{N_{Colocalized}}{N_{ChannelSelected}}$</span>.</li>
<li>Percentage colocalized in ROI, <span
class="math inline">$\frac{N_{ROIColocalized}}{N_{ROI}}$</span>.</li>
<li>Percentage of material colocalized, <span
class="math inline">$\frac{I_{ColocalizedChannelSelected}}{I_{ChannelSelected}}$</span>.</li>
<li>Percentage of material colocalized in ROI <span
class="math inline">$\frac{I_{ROIColocalizedChannelSelected}}{I_{ROIChannelSelected}}$</span>.</li>
<li>Manders coefficient.</li>
<li>Manders coefficient in ROI.</li>
<li>Pearson correlation coefficient.</li>
<li>Pearson correlation coefficient in colocalization.</li>
<li>Pearson correlation coefficient in ROI.</li>
<li>Spearman correlation coefficient.</li>
<li>Spearman correlation coefficient in colocalization.</li>
<li>Spearman correlation coefficient in ROI.</li>
</ol>
<p>Where:</p>
<ul>
<li><span
class="math inline"><em>N</em><sub><em>C</em><em>o</em><em>l</em><em>o</em><em>c</em><em>a</em><em>l</em><em>i</em><em>z</em><em>e</em><em>d</em></sub></span>
is the number of voxels in the colocalized region.</li>
<li><span
class="math inline"><em>N</em><sub><em>I</em><em>m</em><em>a</em><em>g</em><em>e</em></sub></span>
is the total number of voxels in the image.</li>
<li><span
class="math inline"><em>N</em><sub><em>C</em><em>h</em><em>a</em><em>n</em><em>n</em><em>e</em><em>l</em><em>S</em><em>e</em><em>l</em><em>e</em><em>c</em><em>t</em><em>e</em><em>d</em></sub></span>
is the number of voxels in the selected channel's mask.</li>
<li><span
class="math inline"><em>N</em><sub><em>R</em><em>O</em><em>I</em><em>C</em><em>o</em><em>l</em><em>o</em><em>c</em><em>a</em><em>l</em><em>i</em><em>z</em><em>e</em><em>d</em></sub></span>
is the number of voxels in the colocalized region that are also in the
ROI mask.</li>
<li><span
class="math inline"><em>N</em><sub><em>R</em><em>O</em><em>I</em></sub></span>
is the number of voxels in the ROI mask.</li>
<li><span
class="math inline"><em>I</em><sub><em>C</em><em>o</em><em>l</em><em>o</em><em>c</em><em>a</em><em>l</em><em>i</em><em>z</em><em>e</em><em>d</em><em>C</em><em>h</em><em>a</em><em>n</em><em>n</em><em>e</em><em>l</em><em>S</em><em>e</em><em>l</em><em>e</em><em>c</em><em>t</em><em>e</em><em>d</em></sub></span>
is the sum of intensities in the selected channel in the colocalized
region.</li>
<li><span
class="math inline"><em>I</em><sub><em>C</em><em>h</em><em>a</em><em>n</em><em>n</em><em>e</em><em>l</em><em>S</em><em>e</em><em>l</em><em>e</em><em>c</em><em>t</em><em>e</em><em>d</em></sub></span>
is the sum of intensities in the selected channel's mask.</li>
<li><span
class="math inline"><em>I</em><sub><em>R</em><em>O</em><em>I</em><em>C</em><em>o</em><em>l</em><em>o</em><em>c</em><em>a</em><em>l</em><em>i</em><em>z</em><em>e</em><em>d</em><em>C</em><em>h</em><em>a</em><em>n</em><em>n</em><em>e</em><em>l</em><em>S</em><em>e</em><em>l</em><em>e</em><em>c</em><em>t</em><em>e</em><em>d</em></sub></span>
is the sum of intensities in the selected channel in the colocalized
region that are also in the ROI mask.</li>
<li><span
class="math inline"><em>I</em><sub><em>R</em><em>O</em><em>I</em><em>C</em><em>h</em><em>a</em><em>n</em><em>n</em><em>e</em><em>l</em><em>S</em><em>e</em><em>l</em><em>e</em><em>c</em><em>t</em><em>e</em><em>d</em></sub></span>
is the sum of intensities in the selected channel's mask in the
ROI.</li>
</ul>
<p>In addition to the above characteristics, the number and sizes of
connected components (objects) that were colocalized is reported for the
entire volume and those that are in the ROI. This information is useful
to determine if colocalization is occurring in large structures or small
ones and if the threshold selections are appropriate, based on the
expected number of objects and their sizes.</p>
<p>SimpleITK expressions are used to define binary masks, regions of
interest. These can be trivial expressions such as simple thresholding
or complex expressions which take into account object sizes and possibly
distances from the objects. If no expression is provided all of the
voxels are used when computing the colocalization characteristics.</p>
<p>One can either type an expression in the "Mask expression" text box
or use the "Preset mask expressions" to pre-populate the textbox and
then edit it if needed (e.g. setting specific values for thresholds
etc.).</p>
<p>The program enables batch colocalization and comparison. When
analyzing images (2D or 3D) that have a single time-point the output is
a single csv file with all of the computed characteristics and a
corresponding bar graph. When analyzing images that have multiple
time-points the output is a single csv file per input image and a line
graph per variable.</p>
<h1 id="examples-of-useful-expressions">Examples of useful
expressions</h1>
<p>To define the objects of interest in the two channels and the
sub-region of interest we use SimpleITK expressions that yield binary
masks. Below are various options for creating these binary masks ordered
according to their complexity:</p>
<ol>
<li><p>Binary mask using a simple threshold:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre
class="sourceCode Python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[i] <span class="op">&gt;</span> <span class="dv">150</span></span></code></pre></div>
</blockquote></li>
<li><p>Binary mask using the Otsu thresholding filter. Additional
thresholding filters available in SimpleITK include
<em>TriangleThreshold</em>, <em>HuangThreshold</em> and
<em>MaximumEntropyThreshold</em> (for details, see the <a
href="https://simpleitk.org/doxygen/latest/html/">SimpleITK
documentation</a>):</p>
<blockquote>
<div class="sourceCode" id="cb2"><pre
class="sourceCode Python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sitk.OtsuThreshold([i], <span class="dv">0</span>, <span class="dv">1</span>)</span></code></pre></div>
</blockquote></li>
<li><p>Binary mask, intensities inside a range of values:</p>
<blockquote>
<div class="sourceCode" id="cb3"><pre
class="sourceCode Python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>sitk.BinaryThreshold([i], lowerThreshold<span class="op">=</span><span class="dv">50</span>, upperThreshold<span class="op">=</span><span class="dv">150</span>)</span></code></pre></div>
</blockquote></li>
<li><p>Rectangular binary mask, a 30x20x5 rectangular region of interest
spanning indexes [5:35, 10:30, 0:5]:</p>
<blockquote>
<div class="sourceCode" id="cb4"><pre
class="sourceCode Python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>sitk.Paste([i]<span class="op">*</span><span class="dv">0</span>, sitk.Image([<span class="dv">30</span>,<span class="dv">20</span>,<span class="dv">5</span>],[i].GetPixelID())<span class="op">+</span><span class="dv">1</span>, sourceSize<span class="op">=</span>[<span class="dv">30</span>,<span class="dv">20</span>,<span class="dv">5</span>], sourceIndex<span class="op">=</span>[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>], destinationIndex<span class="op">=</span>[<span class="dv">5</span>,<span class="dv">10</span>,<span class="dv">0</span>])</span></code></pre></div>
</blockquote></li>
<li><p>Binary mask via thresholding and only retaining the largest
connected component. Threshold the channel, get all connected
components, then sort the components according to size, discarding those
smaller than a minimum size and create a binary mask corresponding to
the largest component, which has a label value of 1 (second largest
component label is 2 etc.):</p>
<blockquote>
<div class="sourceCode" id="cb5"><pre
class="sourceCode Python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sitk.RelabelComponent(sitk.ConnectedComponent([i]<span class="op">&gt;</span><span class="dv">100</span>), minimumObjectSize <span class="op">=</span> <span class="dv">50</span>)<span class="op">==</span><span class="dv">1</span></span></code></pre></div>
</blockquote></li>
<li><p>Binary mask via thresholding and only retaining connected
components larger than a minimal object size in voxels. Threshold a
specific channel, get all connected components, then sort the components
according to size, discarding those smaller than a minimum size and
create a binary mask from them (one can readily replace the single
threshold with the expression denoting a range of values given
above):</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre
class="sourceCode Python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>sitk.RelabelComponent(sitk.ConnectedComponent([i]<span class="op">&gt;</span><span class="dv">100</span>), minimumObjectSize <span class="op">=</span> <span class="dv">50</span>)<span class="op">!=</span><span class="dv">0</span></span></code></pre></div>
</blockquote></li>
<li><p>Binary mask via thresholding and then enlarging the mask to
include all voxels that are less than 5nm from the original mask (<a
href="https://en.wikipedia.org/wiki/Dilation_(morphology)">dilation
operation</a>).</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre
class="sourceCode Python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>sitk.Abs(sitk.SignedMaurerDistanceMap(sitk.BinaryThreshold([i], lowerThreshold<span class="op">=</span><span class="dv">50</span>, upperThreshold<span class="op">=</span><span class="dv">150</span>),</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                                      insideIsPositive<span class="op">=</span><span class="va">False</span>, squaredDistance<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                                      useImageSpacing<span class="op">=</span><span class="va">True</span>)) <span class="op">&lt;=</span> <span class="fl">5.0</span></span></code></pre></div>
</blockquote></li>
</ol>
</body>
</html>
